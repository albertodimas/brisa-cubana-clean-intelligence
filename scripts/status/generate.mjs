#!/usr/bin/env node
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, "..", "..");
const statusFile = path.join(repoRoot, "docs", "overview", "status.md");

const DEFAULT_REPO = "albertodimas/brisa-cubana-clean-intelligence";
const DEFAULT_VERCEL_PROJECT = "prj_n11x8GsVN5qDw0eOFAcQiOfpc0Zg";

const startMarker = "<!-- STATUS:AUTOGENERATED -->";
const endMarker = "<!-- STATUS:AUTOGENERATED END -->";

function formatDateTime(value) {
  if (!value) return "desconocido";
  try {
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return value;
    return new Intl.DateTimeFormat("es-ES", {
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false,
      timeZone: "UTC",
    }).format(date) + " UTC";
  } catch {
    return value;
  }
}

async function getGithubRuns() {
  const repo = process.env.BRISA_REPO || process.env.GITHUB_REPOSITORY || DEFAULT_REPO;
  const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN || process.env.GITHUB_ACCESS_TOKEN;
  const apiUrl = `https://api.github.com/repos/${repo}/actions/runs?per_page=5`;

  if (!token) {
    return {
      lines: [">   • Configura `GITHUB_TOKEN` o `GH_TOKEN` para listar ejecuciones recientes."],
      note: "Sin token de GitHub, no se pudieron recuperar los workflows.",
    };
  }

  try {
    const response = await fetch(apiUrl, {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github+json",
      },
    });

    if (!response.ok) {
      throw new Error(`GitHub API respondió ${response.status}`);
    }

    const data = await response.json();
    const runs = (data.workflow_runs || []).slice(0, 5);

    if (runs.length === 0) {
      return {
        lines: [">   • No se encontraron runs recientes."],
      };
    }

    const lines = runs.map((run) => {
      const name = run.name || run.display_title || "Workflow";
      const status = run.status || "desconocido";
      const conclusion = run.conclusion || "pendiente";
      const createdAt = formatDateTime(run.created_at);
      const url = run.html_url || run.url || "";
      const suffix = url ? ` – ${url}` : "";
      return `>   • ${name}: ${status}/${conclusion} (${createdAt})${suffix}`;
    });

    return { lines };
  } catch (error) {
    return {
      lines: [">   • Error consultando GitHub Actions (ver consola)."],
      error,
    };
  }
}

async function getVercelDeployment() {
  const token = process.env.VERCEL_ACCESS_TOKEN || process.env.VERCEL_TOKEN;
  const projectId = process.env.VERCEL_PROJECT_ID || DEFAULT_VERCEL_PROJECT;
  const teamId = process.env.VERCEL_TEAM_ID;

  if (!token) {
    return {
      line: "Configura `VERCEL_ACCESS_TOKEN` y `VERCEL_PROJECT_ID` para consultar deployments.",
    };
  }

  const url = new URL("https://api.vercel.com/v6/deployments");
  url.searchParams.set("projectId", projectId);
  url.searchParams.set("limit", "1");
  if (teamId) {
    url.searchParams.set("teamId", teamId);
  }

  try {
    const response = await fetch(url, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      throw new Error(`Vercel API respondió ${response.status}`);
    }

    const data = await response.json();
    const deployments = data.deployments || data;
    const deployment = Array.isArray(deployments) ? deployments[0] : deployments.deployments?.[0];

    if (!deployment) {
      return {
        line: "No se encontraron deployments recientes para el proyecto.",
      };
    }

    const urlValue = deployment.url ? `https://${deployment.url}` : "sin URL";
    const state = deployment.state || deployment.readyState || "desconocido";
    const createdAt = formatDateTime(deployment.createdAt || deployment.created_at);
    return {
      line: `${urlValue} (${state}, ${createdAt})`,
    };
  } catch (error) {
    return {
      line: "Error consultando deployments de Vercel (ver consola).",
      error,
    };
  }
}

function buildBlock({ generatedAt, deployment, runs }) {
  const timestamp = formatDateTime(generatedAt);
  const lines = [
    `> **Resumen vigente (${timestamp})**`,
    `> - Último deployment: ${deployment.line}`,
    '> - Últimos runs CI:',
    ...(runs.lines.length ? runs.lines : ['>   • Sin datos de GitHub Actions.']),
    '> - Generado con `node scripts/status/generate.mjs`'
  ];
  return lines.join('\n');
}

async function updateStatusFile(block) {
  const content = await fs.readFile(statusFile, "utf8");
  const startIndex = content.indexOf(startMarker);
  const endIndex = content.indexOf(endMarker);

  if (startIndex === -1 || endIndex === -1 || endIndex <= startIndex) {
    throw new Error("No se encontraron los marcadores de estado automático en docs/overview/status.md");
  }

  const before = content.slice(0, startIndex + startMarker.length);
  const after = content.slice(endIndex);
  const newContent = `${before}\n${block}\n${after}`;
  await fs.writeFile(statusFile, newContent, "utf8");
}

const generatedAt = new Date().toISOString();

const [deployment, runs] = await Promise.all([
  getVercelDeployment(),
  getGithubRuns(),
]);

if (deployment.error) {
  console.warn("[vercel]", deployment.error.message || deployment.error);
}
if (runs.error) {
  console.warn("[github]", runs.error.message || runs.error);
}
if (deployment.note) {
  console.warn("[vercel]", deployment.note);
}

const block = buildBlock({ generatedAt, deployment, runs });
await updateStatusFile(block);

console.log("Bloque de estado actualizado correctamente.");
console.log(block);
