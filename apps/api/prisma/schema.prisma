generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String?
  phone        String?
  role         UserRole @default(CLIENT)
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  bookings            Booking[]
  properties          Property[]
  reconciliationNotes ReconciliationNote[] @relation("UserReconciliationNotes")
  resolvedNotes       ReconciliationNote[] @relation("UserResolvedNotes")
  conversations       Conversation[]
  refreshTokens       RefreshToken[]

  @@index([role])
  @@index([createdAt])
  @@map("users")
}

enum UserRole {
  CLIENT
  STAFF
  ADMIN
}

model Property {
  id        String       @id @default(cuid())
  name      String
  address   String
  city      String       @default("Miami")
  state     String       @default("FL")
  zipCode   String
  type      PropertyType
  size      Int? // square feet
  bedrooms  Int?
  bathrooms Int?
  notes     String?
  userId    String
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  bookings Booking[]

  @@index([userId])
  @@index([type])
  @@index([city, state])
  @@index([createdAt])
  @@map("properties")
}

enum PropertyType {
  RESIDENTIAL
  VACATION_RENTAL
  OFFICE
  HOSPITALITY
}

model Service {
  id          String   @id @default(cuid())
  name        String
  description String?
  basePrice   Decimal  @db.Decimal(10, 2)
  duration    Int // minutes
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  bookings Booking[]

  @@index([active])
  @@index([basePrice])
  @@map("services")
}

model Booking {
  id                  String               @id @default(cuid())
  userId              String
  user                User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  propertyId          String
  property            Property             @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  serviceId           String
  service             Service              @relation(fields: [serviceId], references: [id], onDelete: Restrict)
  scheduledAt         DateTime
  completedAt         DateTime?
  status              BookingStatus        @default(PENDING)
  totalPrice          Decimal              @db.Decimal(10, 2)
  notes               String?
  paymentIntentId     String?
  checkoutSessionId   String?
  paymentStatus       PaymentStatus        @default(PENDING_PAYMENT)
  reconciliationNotes ReconciliationNote[] @relation("BookingNotes")
  cleanScoreReport    CleanScoreReport?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt

  @@index([userId])
  @@index([propertyId])
  @@index([serviceId])
  @@index([status])
  @@index([paymentStatus])
  @@index([scheduledAt])
  @@index([createdAt])
  @@index([userId, status])
  @@index([propertyId, scheduledAt])
  @@index([status, paymentStatus])
  @@map("bookings")
}

model ReconciliationNote {
  id           String     @id @default(cuid())
  bookingId    String
  booking      Booking    @relation("BookingNotes", fields: [bookingId], references: [id], onDelete: Cascade)
  authorId     String
  author       User       @relation("UserReconciliationNotes", fields: [authorId], references: [id], onDelete: Cascade)
  message      String     @db.Text
  status       NoteStatus @default(OPEN)
  resolvedById String?
  resolvedBy   User?      @relation("UserResolvedNotes", fields: [resolvedById], references: [id])
  resolvedAt   DateTime?
  createdAt    DateTime   @default(now())

  @@index([bookingId])
  @@index([authorId])
  @@index([status])
  @@index([createdAt])
  @@map("reconciliation_notes")
}

model PaymentAlert {
  id              String   @id @default(cuid())
  failedPayments  Int
  pendingPayments Int
  payloadHash     String
  triggeredAt     DateTime @default(now())

  @@index([payloadHash, triggeredAt])
  @@map("payment_alerts")
}

enum NoteStatus {
  OPEN
  RESOLVED
}

enum BookingStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING_PAYMENT
  PAID
  REQUIRES_ACTION
  REFUNDED
  FAILED
}

enum CleanScoreStatus {
  DRAFT
  PUBLISHED
}

model CleanScoreReport {
  id        String  @id @default(cuid())
  bookingId String  @unique
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  // CleanScore metrics
  score   Float // Overall CleanScore (0-100)
  metrics Json // Detailed metrics object

  // Report content
  teamMembers     Json // Array of team member names
  photos          Json @default("[]") // Array of photo objects {url, caption, category}
  videos          Json @default("[]") // Array of video URLs
  checklist       Json @default("[]") // Array of checklist items with status
  observations    String? @db.Text
  recommendations Json @default("[]") // Array of recommendation strings

  // Metadata
  status      CleanScoreStatus @default(DRAFT)
  generatedBy String // User ID who generated the report
  sentToEmail String? // Email where report was sent
  pdfUrl      String? // S3/storage URL for PDF (future)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bookingId])
  @@index([createdAt])
  @@map("cleanscore_reports")
}

model Conversation {
  id         String              @id @default(cuid())
  userId     String
  user       User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  title      String?
  status     ConversationStatus  @default(ACTIVE)
  channel    ConversationChannel @default(WEB)
  bookingId  String?
  propertyId String?
  messages   Message[]
  createdAt  DateTime            @default(now())
  updatedAt  DateTime            @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("conversations")
}

model Message {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  role           MessageRole
  content        String       @db.Text
  model          String?
  tokens         Int?
  context        Json?
  createdAt      DateTime     @default(now())

  @@index([conversationId])
  @@index([createdAt])
  @@map("messages")
}

enum ConversationStatus {
  ACTIVE
  RESOLVED
  ARCHIVED
}

enum ConversationChannel {
  WEB
  WHATSAPP
  SMS
  EMAIL
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  isRevoked Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token, isRevoked])
  @@index([expiresAt])
  @@map("refresh_tokens")
}
